{
    "docs": [
        {
            "location": "/",
            "text": "Capture Agent API Upgrade\n\n\n\n\nCapture Agent API v2 (Draft)\n\n\nOlder Decisions About CA-API\n\n\nSome Random Thoughts\n\n\nNotes From Opencast Summit 2015",
            "title": "Home"
        },
        {
            "location": "/#capture-agent-api-upgrade",
            "text": "Capture Agent API v2 (Draft)  Older Decisions About CA-API  Some Random Thoughts  Notes From Opencast Summit 2015",
            "title": "Capture Agent API Upgrade"
        },
        {
            "location": "/api/",
            "text": "Capture Agent API (Version 2)\n\n\nworking draft\n\n\nThis document specifies the communication between Opencast enabled capture\ndevices (capture agents) and Opencast itself. It defines an extension or\nmodification of the already existing API for Opencast 2.2 and prior versions.\n\n\nA basic idea behind this API update is to have a simple base or core API and\nseveral, optional extensions which capture agents may implement to extend their\nfunctionality.\n\n\nPrimary Changes Compared to CA-APIv1\n\n\n\n\nRegistering capture agents\n\n\nThe URL is optional\n\n\n\n\n\n\nGetting calendar/schedule\n\n\nThe format can be specified\n\n\nJSON is available additional to iCal\n\n\n\n\n\n\nSetting capture agent configuration is available as extension\n\n\n\n\nBase API\n\n\nThis part of the API is mandatory for CA vendors.\n\n\nNote: This is a slightly modified version of the current API with some\nadditional clarifications and without the need to send configuration data to\nthe core.\n\n\nGeneral Capture Agent Behavior\n\n\nThe following rules apply to the capture agent base API as well as to all\nextensions if not explicitly defined otherwise.\n\n\n\n\nThe core must not attempt to connect to the agent. The communication is\n  unidirectional from agent to core. Extensions may ignore this rule, but even\n  then, agents have to work without a bidirectional connection.\n\n\nThe agent must try to send its state to the core on a semi regular basis.\n  This should happen at least once the state changes (e.g. a recording is\n  started, stopped, \u2026)\n\n\nThe agent must try to send the recording state to the core on a semi regular\n  basis. This should happen at least once the recording state changes (e.g. a\n  recording is started, stopped or failed)\n\n\nThe agent should try to update its calendaring data on a regular bases\n\n\nThe agent is required to request the locations of the required REST endpoints\n  from the service registry on a semi regular basis\n\n\nIf multiple endpoints for one task are available (e.g. multiple ingest\n  endpoints) the endpoint to talk to has to be picked randomly (random function\n  with uniform distribution) to ensure a balanced load on the system\n\n\nIf there is an error during the communication with the core (e.g. network\n  failure), the agent must assume the old data to be still valid (schedule and\n  endpoints) and may ignore failures on status requests\n\n\n\n\nQuick Overview\n\n\nThe following pseudo code defines what you are required to do as a capture\nagent. Note, that these are only the minimal requirements and you can do better.\nA more specific explanation of all the steps can be found below.\n\n\nrequest rest endpoints              (1)\nregister ca and set status          (2)\nrepeat:\n   while no recording\n      get schedule/calendar         (3)\n   set agent and recording state    (4)\n   start recording                  (5)\n   set agent and recording state    (6)\n   update ingest endpoints          (7)\n   ingest recording                 (8)\n   set agent and recording state    (9)\n\n\n\nGet Endpoint Locations From Service Registry (1)\n\n\nFirst, you need to get the locations of the REST endpoints to talk to.  These\ninformation can be retrieved from the central service registry. It is likely\nthat Matterhorn is running as a distributed system which means you cannot\nexpect all endpoints on a single host.\n\n\nThree endpoint locations need to be requested:\n\n\n\n\nThe capture-admin endpoint to register the agent and set status and\n  configuration: org.opencastproject.capture.admin\n\n\nThe scheduler endpoint to get the current schedule for the agent from:\n  org.opencastproject.scheduler\n\n\nThe ingest endpoint to upload the recordings to once they are done:\n  org.opencastproject.ingest\n\n\n\n\nTo ask for an endpoint you would send an HTTP GET request to\n\n\n${HOST}/services/available.json?serviceType=\nSERVICE\n\n\n\n\nA result would look like\n\n\n{\n  \"services\" : {\n    \"service\" : {\n      \"active\" : true,\n      \"host\" : \"http://example.opencast.org:8080\",\n      \"path\" : \"/capture-admin\",\n      ...\n    }\n  }\n}\n\n\n\nThese endpoints should be requested once when starting up the capture agent\n(1). While the capture-admin and scheduler endpoints may then be assumed to\nnever change during the runtime of the capture agent, the ingest endpoint may\nchange and the data should be re-requested every time before uploading\n(ingesting) data to the core.\n\n\nRegister the Capture Agent and set Current Status (2)\n\n\nOnce the endpoints to talk to are knows, it is time to register the capture\nagent at the core so that scheduled events can be added. This can be done by\nsending an HTTP POST request to:\n\n\n${CAPTURE-ADMIN-ENDPOINT}/agents/\nname\n\n\n\n\n\u2026including the following data fields:\n\n\nstate=idle\naddress=http(s)://\nca-web-ui\n (OPTIONAL)\n\n\n\nThe name has to be a unique identifier of a single capture agent. Using the\nsame name for several agents would mean sharing the same schedule and status\nwhich in general should be avoided.\n\n\nSending this request will register the capture agent. After doing this, the\ncapture agent should appear in the admin interface and schedules can be added\nfor this agent.\n\n\nGetting the Calendar/Schedule (3)\n\n\nThe calendar can be retrieved by sending an HTTP GET request to\n\n\n${SCHEDULER-ENDPOINT}/calendars\n.format\n?agentid=\nname\n\n\n\n\nThe format can either be \n.ical\n or \n.json\n. If the format is omitted, iCal is\nbeing returned.  The file contains all scheduled upcoming recordings the\ncapture agent should handle.\n\n\nDepending on the amount of recordings scheduled for the particular capture\nagent, this file may become very large. That is why there are two way of\nlimiting the amount of necessary data to transfer and process:\n\n\n\n\n\n\nSend along the optional parameter cutoff to limit the schedule to a\n    particular time span in the future.\n\n\n${SCHEDULER-ENDPOINT}/calendars?agentid=\ncutoff=\n\n\n\n\n\n\nThe value for cutoff represents milliseconds from now.\n\n\n\n\nUse the HTTP ETag and If-Not-Modified header the have Matterhorn only sent\n    schedules when they have actually changed.\n\n\n\n\nSet Agent and Recording State (4)\n\n\nSetting the agent state is identical to the registration of the capture agent\nand done by sending an HTTP POST request to:\n\n\n${CAPTURE-ADMIN-ENDPOINT}/agents/\nname\n\n\n\n\n\u2026including the following data fields:\n\n\nstate=capturing\naddress=http(s)://\nca-web-ui\n (OPTIONAL)\n\n\n\nAdditionally, set the recording state with an HTTP POST request to\n\n\n${CAPTURE-ADMIN-ENDPOINT}/recordings/\nrecording_id\n\n\n\n\n\u2026including the data field:\n\n\nstate=capturing\n\n\n\nRecording (5)\n\n\nThis task is device specific. You may execute any code necessary to get the\nrecording on your device.\n\n\nSet Agent and Recording State (6)\n\n\nThis step is identical to step 4 except for the state.\n\n\nIf the recording has failed, the recording state is updated with\n\ncapture_error\n while the agents state is set back to \nidle\n if the error is\nnon-permanent.\n\n\nIf the recording was successful, both states are set to \nuploading\n.\n\n\nGet Ingest Endpoint Locations From Service Registry (7)\n\n\nThis step is identical to step 1 expect that it is sufficient to request the\nlocation for the service \norg.opencastproject.ingest\n only. If this request\nfails, assume the old data to be valid.\n\n\nIngest (Upload) Recording (8)\n\n\nUse the ingest endpoint to upload the recording.\n\n\n\n\nRecording files may be deleted if the ingest was successful.\n\n\nRecordings should be stored in case of a failure.\n\n\n\n\nTODO: Descripbe ingest requests\n\n\nSet Agent and Recording State (6)\n\n\nAgain, this step is identical to step 4 except for the state.\n\n\nIf the upload has failed, the recording state is updated with\n\nupload_error\n while the agents state is set back to \nidle\n if the error is\nnon-permanent.\n\n\nIf the upload was successful, the recording status is set to \nupload_finished\n\nwhile the agents state is set back to \nidle\n.\n\n\nExtensions\n\n\nExtensions may be specified as addition to the base API. Extensions are always\nrequired to be optional and parts of them may not be required by Opencast\nitself or capture agents to function.\n\n\nExtension: Capture Agent Configuration (id: CFG)\n\n\nTODO: Old configuration but accepts JSON as well\n\n\nExtension: Recording Preview (id: PREVIEW)\n\n\nTODO: Provide locazion of preview image or stream for Opencast to use as\npreview on a capture agent dashboard\n\n\nExtension: Bi-directional CA Communication (id: TALKBACK)\n\n\nTODO: Enable use of WebSockets or longpolling for faster communication and\nless stress on the admin node.",
            "title": "Api"
        },
        {
            "location": "/api/#capture-agent-api-version-2",
            "text": "working draft  This document specifies the communication between Opencast enabled capture\ndevices (capture agents) and Opencast itself. It defines an extension or\nmodification of the already existing API for Opencast 2.2 and prior versions.  A basic idea behind this API update is to have a simple base or core API and\nseveral, optional extensions which capture agents may implement to extend their\nfunctionality.",
            "title": "Capture Agent API (Version 2)"
        },
        {
            "location": "/api/#primary-changes-compared-to-ca-apiv1",
            "text": "Registering capture agents  The URL is optional    Getting calendar/schedule  The format can be specified  JSON is available additional to iCal    Setting capture agent configuration is available as extension",
            "title": "Primary Changes Compared to CA-APIv1"
        },
        {
            "location": "/api/#base-api",
            "text": "This part of the API is mandatory for CA vendors.  Note: This is a slightly modified version of the current API with some\nadditional clarifications and without the need to send configuration data to\nthe core.  General Capture Agent Behavior  The following rules apply to the capture agent base API as well as to all\nextensions if not explicitly defined otherwise.   The core must not attempt to connect to the agent. The communication is\n  unidirectional from agent to core. Extensions may ignore this rule, but even\n  then, agents have to work without a bidirectional connection.  The agent must try to send its state to the core on a semi regular basis.\n  This should happen at least once the state changes (e.g. a recording is\n  started, stopped, \u2026)  The agent must try to send the recording state to the core on a semi regular\n  basis. This should happen at least once the recording state changes (e.g. a\n  recording is started, stopped or failed)  The agent should try to update its calendaring data on a regular bases  The agent is required to request the locations of the required REST endpoints\n  from the service registry on a semi regular basis  If multiple endpoints for one task are available (e.g. multiple ingest\n  endpoints) the endpoint to talk to has to be picked randomly (random function\n  with uniform distribution) to ensure a balanced load on the system  If there is an error during the communication with the core (e.g. network\n  failure), the agent must assume the old data to be still valid (schedule and\n  endpoints) and may ignore failures on status requests   Quick Overview  The following pseudo code defines what you are required to do as a capture\nagent. Note, that these are only the minimal requirements and you can do better.\nA more specific explanation of all the steps can be found below.  request rest endpoints              (1)\nregister ca and set status          (2)\nrepeat:\n   while no recording\n      get schedule/calendar         (3)\n   set agent and recording state    (4)\n   start recording                  (5)\n   set agent and recording state    (6)\n   update ingest endpoints          (7)\n   ingest recording                 (8)\n   set agent and recording state    (9)  Get Endpoint Locations From Service Registry (1)  First, you need to get the locations of the REST endpoints to talk to.  These\ninformation can be retrieved from the central service registry. It is likely\nthat Matterhorn is running as a distributed system which means you cannot\nexpect all endpoints on a single host.  Three endpoint locations need to be requested:   The capture-admin endpoint to register the agent and set status and\n  configuration: org.opencastproject.capture.admin  The scheduler endpoint to get the current schedule for the agent from:\n  org.opencastproject.scheduler  The ingest endpoint to upload the recordings to once they are done:\n  org.opencastproject.ingest   To ask for an endpoint you would send an HTTP GET request to  ${HOST}/services/available.json?serviceType= SERVICE   A result would look like  {\n  \"services\" : {\n    \"service\" : {\n      \"active\" : true,\n      \"host\" : \"http://example.opencast.org:8080\",\n      \"path\" : \"/capture-admin\",\n      ...\n    }\n  }\n}  These endpoints should be requested once when starting up the capture agent\n(1). While the capture-admin and scheduler endpoints may then be assumed to\nnever change during the runtime of the capture agent, the ingest endpoint may\nchange and the data should be re-requested every time before uploading\n(ingesting) data to the core.  Register the Capture Agent and set Current Status (2)  Once the endpoints to talk to are knows, it is time to register the capture\nagent at the core so that scheduled events can be added. This can be done by\nsending an HTTP POST request to:  ${CAPTURE-ADMIN-ENDPOINT}/agents/ name   \u2026including the following data fields:  state=idle\naddress=http(s):// ca-web-ui  (OPTIONAL)  The name has to be a unique identifier of a single capture agent. Using the\nsame name for several agents would mean sharing the same schedule and status\nwhich in general should be avoided.  Sending this request will register the capture agent. After doing this, the\ncapture agent should appear in the admin interface and schedules can be added\nfor this agent.  Getting the Calendar/Schedule (3)  The calendar can be retrieved by sending an HTTP GET request to  ${SCHEDULER-ENDPOINT}/calendars .format ?agentid= name   The format can either be  .ical  or  .json . If the format is omitted, iCal is\nbeing returned.  The file contains all scheduled upcoming recordings the\ncapture agent should handle.  Depending on the amount of recordings scheduled for the particular capture\nagent, this file may become very large. That is why there are two way of\nlimiting the amount of necessary data to transfer and process:    Send along the optional parameter cutoff to limit the schedule to a\n    particular time span in the future.  ${SCHEDULER-ENDPOINT}/calendars?agentid= cutoff=    The value for cutoff represents milliseconds from now.   Use the HTTP ETag and If-Not-Modified header the have Matterhorn only sent\n    schedules when they have actually changed.   Set Agent and Recording State (4)  Setting the agent state is identical to the registration of the capture agent\nand done by sending an HTTP POST request to:  ${CAPTURE-ADMIN-ENDPOINT}/agents/ name   \u2026including the following data fields:  state=capturing\naddress=http(s):// ca-web-ui  (OPTIONAL)  Additionally, set the recording state with an HTTP POST request to  ${CAPTURE-ADMIN-ENDPOINT}/recordings/ recording_id   \u2026including the data field:  state=capturing  Recording (5)  This task is device specific. You may execute any code necessary to get the\nrecording on your device.  Set Agent and Recording State (6)  This step is identical to step 4 except for the state.  If the recording has failed, the recording state is updated with capture_error  while the agents state is set back to  idle  if the error is\nnon-permanent.  If the recording was successful, both states are set to  uploading .  Get Ingest Endpoint Locations From Service Registry (7)  This step is identical to step 1 expect that it is sufficient to request the\nlocation for the service  org.opencastproject.ingest  only. If this request\nfails, assume the old data to be valid.  Ingest (Upload) Recording (8)  Use the ingest endpoint to upload the recording.   Recording files may be deleted if the ingest was successful.  Recordings should be stored in case of a failure.   TODO: Descripbe ingest requests  Set Agent and Recording State (6)  Again, this step is identical to step 4 except for the state.  If the upload has failed, the recording state is updated with upload_error  while the agents state is set back to  idle  if the error is\nnon-permanent.  If the upload was successful, the recording status is set to  upload_finished \nwhile the agents state is set back to  idle .",
            "title": "Base API"
        },
        {
            "location": "/api/#extensions",
            "text": "Extensions may be specified as addition to the base API. Extensions are always\nrequired to be optional and parts of them may not be required by Opencast\nitself or capture agents to function.  Extension: Capture Agent Configuration (id: CFG)  TODO: Old configuration but accepts JSON as well  Extension: Recording Preview (id: PREVIEW)  TODO: Provide locazion of preview image or stream for Opencast to use as\npreview on a capture agent dashboard  Extension: Bi-directional CA Communication (id: TALKBACK)  TODO: Enable use of WebSockets or longpolling for faster communication and\nless stress on the admin node.",
            "title": "Extensions"
        },
        {
            "location": "/decisions/",
            "text": "Things that have already been decided\n\n\n#proposal by Greg: CA API #proposal (Closes 2015-01-30T15:00)\n\n\nHow to document changes\n\n\n\n\nDiscussion should happen on list\n\n\nDecision summaries should be sent to vendor list\n\n\n\n\nHow to deprecate outdated functionality\n\n\n\n\nTwo CA-API version support\n\n\nParts that are deprecated in CA-API version x may be removed in x+2\n\n\n\n\nVersioning\n\n\n\n\n\n\nAvailable versions are listed at a /services/versions.{format} endpoint\n    which returns a blob of metadata that looks like:\n\n\nversions {\n  available: [ \"v1.0.0\", \"v1.1.0\" ]\n  default: \"v1.1.0\"\n}\n\n\n\n\n\n\n\nRequests may specify a specific version in their \nHTTP ACCEPT\n header.  For example:\n\n\napplication/vnd.opencast.capture.1.0.0+xml\n\n\n\n\n\n\n\nResponses specify the version in their Content-Type header\n\n\n\n\nUnspecified versions will default to the default version as advertised by\n    the versions endpoint.\n\n\nUnknown or unparsable versions lead to a 400 (bad request) response",
            "title": "Decisions"
        },
        {
            "location": "/decisions/#things-that-have-already-been-decided",
            "text": "#proposal by Greg: CA API #proposal (Closes 2015-01-30T15:00)  How to document changes   Discussion should happen on list  Decision summaries should be sent to vendor list   How to deprecate outdated functionality   Two CA-API version support  Parts that are deprecated in CA-API version x may be removed in x+2   Versioning    Available versions are listed at a /services/versions.{format} endpoint\n    which returns a blob of metadata that looks like:  versions {\n  available: [ \"v1.0.0\", \"v1.1.0\" ]\n  default: \"v1.1.0\"\n}    Requests may specify a specific version in their  HTTP ACCEPT  header.  For example:  application/vnd.opencast.capture.1.0.0+xml    Responses specify the version in their Content-Type header   Unspecified versions will default to the default version as advertised by\n    the versions endpoint.  Unknown or unparsable versions lead to a 400 (bad request) response",
            "title": "Things that have already been decided"
        },
        {
            "location": "/random-thoughts/",
            "text": "Some Random Thoughts\n\n\nJust noted here so they will not get lost\n\n\nBy defining a base API and extensions, CA vendors can provide a matrix as an\neasy to grasp way for users to see what the device is capable of. Example:\n\n\nBase API                     \u2713\nLive status                  \u2713\nPreview image                \u2715\nRecording buffer             \u2713\nLive streaming               \u2715\nInput selection              \u2713\nEnvironment selection        \u2715",
            "title": "Random thoughts"
        },
        {
            "location": "/random-thoughts/#some-random-thoughts",
            "text": "Just noted here so they will not get lost  By defining a base API and extensions, CA vendors can provide a matrix as an\neasy to grasp way for users to see what the device is capable of. Example:  Base API                     \u2713\nLive status                  \u2713\nPreview image                \u2715\nRecording buffer             \u2713\nLive streaming               \u2715\nInput selection              \u2713\nEnvironment selection        \u2715",
            "title": "Some Random Thoughts"
        },
        {
            "location": "/summit2015-wishes/",
            "text": "Requirements/Wishes Extracted From Talk With Vendors and Users\n\n\nNotes from Lars based on CA-API Sessions @Mancheser-Conference \n Extron Meeting\n\n\n\n\nDo not break the old API\n\n\nPoint made by several vendors\n\n\nOld devices that are out there right now should still work\n\n\nWe need versioning\n\n\n\n\n\n\nMake the API modular\n\n\nNot all CAs need to provide everything\n\n\nCreate a small, easy to implement base API\n\n\nCreate extensions\n\n\nBase API could be current mandatory API part:\n\n\nsend status\n\n\nget schedule\n\n\ningest\n\n\nExtensions could be things like\n\n\nProvides live status information\n        - Preview images\n         - Preview stream\n\n\nSelection of inputs\n\n\nSelection of environments\n\n\n\n\n\n\nClearly define how metadata should be handled\n\n\nWhat should a CA do with passed metadata\n\n\nIs a CA allowed to modify or add metadata\n\n\nHow should metadata be added\n\n\n\n\n\n\nCapture device API\n\n\nDefine common places to get status information from a capture agent\n\n\nDefine information a capture agent should provide\n\n\nExamples\n\n\nJSON with status information\n\n\npreview image\n\n\nFor tools like CA dashboard\n\n\n\n\n\n\nWebSocket Communication for Server to CA Communication\n\n\nIdea from vendors\n\n\nMakes it possible to get through firewall\n\n\nNo real example for what this would be used\n\n\n\n\n\n\nNormalization of Input Names\n\n\nIf a screen recording is selected it should be possible to swap the CA\n    and it should not break because it does not know the term\n\n\nIf terms are not knows CA should fall back to default inputs\n\n\nWe should define a set of recommended terms to use\n\n\nCA vendors should still be able to extend this set of terms\n\n\n\n\n\n\nSwitch to common format for input specification\n\n\nMost things can be defined using JSON\n\n\nNot using JSON at the moment:\n\n\niCal for schedule\n\n\nXML for inputs\n\n\n\n\n\n\nLet CA specify environments\n\n\nAdditional settings for ca to set\n\n\nExample: A CA may specify that it supports an environment \u201cBlackboard\u201d\n    which, attached to a scheduled recording definition will make the CA send\n    some commands to a PTZ camera, \u2026\n\n\nCombine this with input specification? \n(-lars)\n\n\nThings that may be done based on an environment:\n\n\nSend HTTP requests\n\n\nSend RS232 commands\n\n\nControl Visca PTZ camera\n\n\n\n\n\n\nProvide a CA test case\n\n\nScript to run against a CA, ensuring basic functionality\n\n\n\n\n\n\nHow to handle live streaming events\n\n\nStart separate discussion on list\n\n\nHarvard DCE has something\n\n\nNCast has something\n\n\n\n\n\n\nAdd support for a CA description \n(MH-8963)",
            "title": "Summit2015 wishes"
        },
        {
            "location": "/summit2015-wishes/#requirementswishes-extracted-from-talk-with-vendors-and-users",
            "text": "Notes from Lars based on CA-API Sessions @Mancheser-Conference   Extron Meeting   Do not break the old API  Point made by several vendors  Old devices that are out there right now should still work  We need versioning    Make the API modular  Not all CAs need to provide everything  Create a small, easy to implement base API  Create extensions  Base API could be current mandatory API part:  send status  get schedule  ingest  Extensions could be things like  Provides live status information\n        - Preview images\n         - Preview stream  Selection of inputs  Selection of environments    Clearly define how metadata should be handled  What should a CA do with passed metadata  Is a CA allowed to modify or add metadata  How should metadata be added    Capture device API  Define common places to get status information from a capture agent  Define information a capture agent should provide  Examples  JSON with status information  preview image  For tools like CA dashboard    WebSocket Communication for Server to CA Communication  Idea from vendors  Makes it possible to get through firewall  No real example for what this would be used    Normalization of Input Names  If a screen recording is selected it should be possible to swap the CA\n    and it should not break because it does not know the term  If terms are not knows CA should fall back to default inputs  We should define a set of recommended terms to use  CA vendors should still be able to extend this set of terms    Switch to common format for input specification  Most things can be defined using JSON  Not using JSON at the moment:  iCal for schedule  XML for inputs    Let CA specify environments  Additional settings for ca to set  Example: A CA may specify that it supports an environment \u201cBlackboard\u201d\n    which, attached to a scheduled recording definition will make the CA send\n    some commands to a PTZ camera, \u2026  Combine this with input specification?  (-lars)  Things that may be done based on an environment:  Send HTTP requests  Send RS232 commands  Control Visca PTZ camera    Provide a CA test case  Script to run against a CA, ensuring basic functionality    How to handle live streaming events  Start separate discussion on list  Harvard DCE has something  NCast has something    Add support for a CA description  (MH-8963)",
            "title": "Requirements/Wishes Extracted From Talk With Vendors and Users"
        }
    ]
}